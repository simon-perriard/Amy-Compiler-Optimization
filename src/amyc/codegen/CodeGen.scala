package amyc
package codegen

import analyzer._
import ast.Identifier
import ast.SymbolicTreeModule.{Call => AmyCall, Div => AmyDiv, And => AmyAnd, Or => AmyOr, _}
import utils.{Context, Pipeline}
import wasm._
import Instructions._
import Utils._

// Generates WebAssembly code for an Amy program
object CodeGen extends Pipeline[(Program, SymbolTable), Module] {
  def run(ctx: Context)(v: (Program, SymbolTable)): Module = {
    val (program, table) = v

    // Generate code for an Amy module
    def cgModule(moduleDef: ModuleDef): List[Function] = {
      val ModuleDef(name, defs, optExpr) = moduleDef
      // Generate code for all functions
      defs.collect { case fd: FunDef if !builtInFunctions(fullName(name, fd.name)) =>
        cgFunction(fd, name, false)
      } ++
        // Generate code for the "main" function, which contains the module expression
        optExpr.toList.map { expr =>
          val mainFd = FunDef(Identifier.fresh("main"), Nil, TypeTree(IntType), expr)
          cgFunction(mainFd, name, true)
        }
    }

    // Generate code for a function in module 'owner'
    def cgFunction(fd: FunDef, owner: Identifier, isMain: Boolean): Function = {
      // Note: We create the wasm function name from a combination of
      // module and function name, since we put everything in the same wasm module.
      val name = fullName(owner, fd.name)
      Function(name, fd.params.size, isMain) { lh =>
        val locals = fd.paramNames.zipWithIndex.toMap
        val body = cgExpr(fd.body)(locals, lh)
        if (isMain) {
          body <:> Drop // Main functions do not return a value,
          // so we need to drop the value generated by their body
        } else {
          body
        }
      }
    }

    // Generate code for an expression expr.
    // Additional arguments are a mapping from identifiers (parameters and variables) to
    // their index in the wasm local variables, and a LocalsHandler which will generate
    // fresh local slots as required.
    def cgExpr(expr: Expr)(implicit locals: Map[Identifier, Int], lh: LocalsHandler): Code = {
      expr match {

        //Literals
        case IntLiteral(value) => Const(value)

        case BooleanLiteral(value) => if (value) Const(1) else Const(0)

        case StringLiteral(value) => mkString(value)

        case UnitLiteral() => Const(0)

        //Variables
        case Variable(name) => GetLocal(locals(name))

        //Binary operations
        case Plus(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Add

        case Minus(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Sub

        case Times(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Mul

        case AmyDiv(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Div

        case Mod(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Rem

        case LessThan(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Lt_s

        case LessEquals(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Le_s

        case AmyAnd(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> And

        case AmyOr(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Or

        case Equals(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Eq

        case Concat(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> concatImpl.code

        case Not(e) => cgExpr(e) <:> If_i32 <:> Const(0) <:> Else <:> Const(1) <:> End

        case Neg(e) => Const(0) <:> cgExpr(e) <:> Sub

        case AmyCall(qname, args) =>
          val function = table.getFunction(qname)
          if (function.isDefined) {
            //function call
            //set the args before calling
            cs2c(args.map(cgExpr(_))) <:> Call(fullName(function.get.owner, qname))
          }else{
            //type constructor
            val constructor = table.getConstructor(qname).get
            val index = constructor.index
            val ADTsize = (1+constructor.argTypes.size)*4 // byte based
            val b = lh.getFreshLocal()
              // Save old memoryBoundary b
            GetGlobal(memoryBoundary) <:> SetLocal(b) <:>
              // Increment memoryBoundary by the size of the allocated ADT
            GetGlobal(memoryBoundary) <:> Const(ADTsize) <:> Add <:> SetGlobal(memoryBoundary) <:>
              // Store the constructor index to address b
            GetLocal(b) <:> Const(index) <:> Store <:>
              // Generate code and store each field in the correct offset of b
              // Before each code generation get base address and the field offset
            cs2c(args.zipWithIndex.map{case(arg, i) => GetLocal(b) <:> adtField(i) <:> cgExpr(arg) <:> Store}) <:>
              // Push b to the stack
            GetLocal(b)
          }

        case Sequence(e1, e2) => cgExpr(e1) <:> cgExpr(e2)

        case Let(df, value, body) =>
          val index = lh.getFreshLocal()
          val newLocals = locals + (df.name -> index)
          cgExpr(value) <:> SetLocal(index) <:> cgExpr(body)(newLocals, lh)

        case Ite(cons, thenn, elze) => cgExpr(cons) <:> If_i32 <:> cgExpr(thenn) <:> Else <:> cgExpr(elze) <:> End

        case Error(msg) => cgExpr(msg) <:> Call("Std_printString") <:> Unreachable

        case Match(scrut, cases) =>
          val scrutVal = lh.getFreshLocal() // will contains the value of the scrut

          def handleCases(cases: List[MatchCase]): Code = {
            if(cases.isEmpty){
              mkString("Match error!") <:> Call("Std_printString") <:> Unreachable
            }else {
              matchAndBind(scrutVal, cases.head.pat) <:> If_i32 <:> cgExpr(cases.head.expr) <:> Else <:> handleCases(cases.tail) <:> End
            }
          }

          def matchAndBind(v: Int, p: Pattern): Code = {

            p match {
              case WildcardPattern() => Const(1)
              case IdPattern(name) => println(locals);locals(name)
                GetLocal(v) <:> SetLocal(locals(name)) <:> Const(1)
              case LiteralPattern(lit) =>
                lit match {
                  case IntLiteral(value) => GetLocal(v) <:> Const(value) <:> Eq
                  case BooleanLiteral(value) => GetLocal(v) <:> (if(value) Const(1) else Const(0)) <:> Eq
                  case StringLiteral(_) => Const(0)
                  case UnitLiteral() => Const(1)
                }
              case CaseClassPattern(constr, args) =>
                //add local variables to locals
                //println(args)
                val newLocals = locals ++ args.zipWithIndex.toMap.mapValues(v => v+locals.size)
                val constrIndex = table.getConstructor(constr).get.index
                GetLocal(v) <:> Load <:> Const(constrIndex) <:> Eq <:> And <:> cs2c(args.zipWithIndex.map{
                  case(arg, i) =>
                    val argVal = lh.getFreshLocal()
                    GetLocal(v) <:> adtField(i) <:> Load <:> SetLocal(argVal) <:> matchAndBind(argVal, arg) <:> And
                })
            }
          }

          cgExpr(scrut) <:> SetLocal(scrutVal) <:> handleCases(cases)

      }
    }

    Module(
      program.modules.last.name.name,
      defaultImports,
      globalsNo,
      wasmFunctions ++ (program.modules flatMap cgModule)
    )

  }
}
